#ifndef _CACHEPP_TESTSUITE_TEMPLATE
#define _CACHEPP_TESTSUITE_TEMPLATE

#include <atomic>
#include <memory>
#include <random>
#include <thread>

#include "src/testsuite.h"

template <typename X, typename D, typename T> cachepp::TestSuite<X, D, T>::TestSuite(const std::shared_ptr<X>& cache) : cache(cache), result(cachepp::TestResult()) {}

template <typename X, typename D, typename T> cachepp::TestResult cachepp::TestSuite<X, D, T>::get_result() { return(this->result); }

template <typename X, typename D, typename T> void cachepp::TestSuite<X, D, T>::correctness(const std::shared_ptr<std::vector<std::shared_ptr<T>>>& lines, size_t n_attempts, bool is_parallel, size_t n_threads) {
	if(is_parallel & !this->cache->get_is_thread_safe()) {
		throw(exceptionpp::InvalidOperation("cachepp::TestSuite::correctness", "attempting to run a cache test in parallel on a non-thread-safe cache"));
	}

	if((!is_parallel && (n_threads != 0)) || (is_parallel && (n_threads == 0))) {
		throw(exceptionpp::InvalidOperation("cachepp::TestResult::push_back", "is_parallel and n_thread provide conflicting data"));
	}

	bool success = false;

	// reset the cache to collect statistics, and to clear all lines to prevent inaccurate miss rates
	this->cache->reset();

	std::shared_ptr<std::atomic<size_t>> n_success (new std::atomic<size_t>(0));

	if(!is_parallel) {
		this->aux_correctness(n_success, lines, n_attempts);
		success = (*n_success == 1);
	} else {
		std::vector<std::thread> threads;
		for(size_t i = 0; i < n_threads; ++i) {
			threads.push_back(std::thread(&cachepp::TestSuite<X, D, T>::aux_correctness, this, n_success, lines, n_attempts));
		}
		for(size_t i = 0; i < n_threads; ++i) {
			threads.at(i).join();
		}

		success = (*n_success == n_threads);
	}

	if(!success) {
		throw(exceptionpp::RuntimeError("cachepp::TestSuite::correctness", "correctness test failed"));
	}
}

/**
 * helper function for the correctness tests -- either called directly or spawned into a thread
 */
template <typename X, typename D, typename T> void cachepp::TestSuite<X, D, T>::aux_correctness(const std::shared_ptr<std::atomic<size_t>>& n_success, const std::shared_ptr<std::vector<std::shared_ptr<T>>>& lines, size_t n_attempts) {
	size_t local_n_success = 0;
	for(size_t i = 0; i < n_attempts; ++i) {
		cachepp::identifier index = rand() % lines->size();
		this->cache->acquire(lines->at(index), D());
		local_n_success += lines->at(index)->get_is_loaded();
		this->cache->release(lines->at(index));
	}
	*n_success += (local_n_success == n_attempts);
}

#endif
