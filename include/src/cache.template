#ifndef _CACHEPP_CACHE_TEMPLATE
#define _CACHEPP_CACHE_TEMPLATE

#include <type_traits>

#include "libs/exceptionpp/exception.h"

#include "src/cache.h"

template <typename T, typename D> cachepp::Cache<T, D>::Cache(cachepp::identifier size) : size(size) {
	if(!std::is_base_of<cachepp::Line, T>::value) {
		throw(exceptionpp::InvalidOperation("cachepp::Cache<T, D>::Cache", "given typename T, typename D is not inherited from cachepp::Line"));
	}
}

template <typename T, typename D> void cachepp::Cache<T, D>::acquire(const std::shared_ptr<T>& arg) {
	// lock_guard auto-calls this->l->unlock upon stack deallocation -- do not need to worry about releasing resources during exceptions
	std::lock_guard<std::mutex> l(this->l);
	if(!this->in(arg)) {
		this->allocate(arg);
	}
}

template <typename T, typename D> void cachepp::Cache<T, D>::clear() {
	std::lock_guard<std::mutex> l(this->l);
	for(typename std::map<cachepp::identifier, std::shared_ptr<T>>::iterator it = this->cache.begin(); it != this->cache.end();) {
		this->cache.erase(it->first);
		it->second->unload();
		it++;
	}
}

/**
 * tests for membership in the cache
 */
template <typename T, typename D> bool cachepp::Cache<T, D>::in(const std::shared_ptr<T>& arg) {
	bool succ = (this->cache.count(arg->get_identifier()) == 1);
	return(succ);
}

/**
 * the function which actually loads the data into the cache
 */
template <typename T, typename D> void cachepp::Cache<T, D>::allocate(const std::shared_ptr<T>& arg) {
	if(this->cache.size() >= this->size) {
		std::shared_ptr<T> target = this->select();
		this->cache.erase(target->get_identifier());
		target->unload();
	}
	arg->load();
	this->cache.insert(std::pair<cachepp::identifier, std::shared_ptr<T>> (arg->get_identifier(), arg));
}

/**
 * selects a cache line for eviction
 *
 * default implementation may need to be overridden in derived classes
 */
template <typename T, typename D> std::shared_ptr<T> cachepp::Cache<T, D>::select() {
	cachepp::identifier heuristic = 0;
	cachepp::identifier target = 0;
	for(typename std::map<cachepp::identifier, std::shared_ptr<T>>::iterator it = this->cache.begin(); it != this->cache.end(); ++it) {
		cachepp::identifier  h = this->heuristic(it->second);
		if(h <= heuristic) {
			heuristic = h;
			target = it->first;
		}
	}
	if(target == 0) {
		throw(exceptionpp::RuntimeError("cachepp::Cache::select", "cannot find a target to evict"));
	}
	return(this->cache.at(target));
}

#endif
